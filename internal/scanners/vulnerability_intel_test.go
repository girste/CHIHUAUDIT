package scanners

import (
	"context"
	"testing"
)

func TestVulnerabilityIntelResult(t *testing.T) {
	result := &VulnerabilityIntelResult{
		CVEsChecked:   1,
		ScanCompleted: true,
		Results: []CVEIntelResult{
			{CVEID: "CVE-2024-1234", Found: true},
		},
	}

	if result.CVEsChecked != 1 {
		t.Errorf("CVEsChecked = %d, want 1", result.CVEsChecked)
	}
	if !result.ScanCompleted {
		t.Error("ScanCompleted should be true")
	}
}

func TestVulnerabilityInfo(t *testing.T) {
	vuln := CVEIntelResult{
		CVEID:       "CVE-2024-1234",
		Severity:    "HIGH",
		CVSSScore:   7.5,
		Description: "Test vulnerability",
		Found:       true,
	}

	if vuln.CVEID != "CVE-2024-1234" {
		t.Errorf("CVEID = %s, want CVE-2024-1234", vuln.CVEID)
	}
	if vuln.CVSSScore != 7.5 {
		t.Errorf("CVSSScore = %f, want 7.5", vuln.CVSSScore)
	}
}

func TestCheckVulnerabilityIntel(t *testing.T) {
	ctx := context.Background()

	t.Run("empty CVE list", func(t *testing.T) {
		result := CheckVulnerabilityIntel(ctx, []string{})
		if result == nil {
			t.Fatal("Result should not be nil")
		}
		if result.CVEsChecked != 0 {
			t.Errorf("CVEsChecked = %d, want 0", result.CVEsChecked)
		}
	})

	t.Run("valid CVE format", func(t *testing.T) {
		// Real API call - may fail in test env, just verify it doesn't panic
		result := CheckVulnerabilityIntel(ctx, []string{"CVE-2024-0001"})
		if result == nil {
			t.Fatal("Result should not be nil")
		}
		// Don't assert on found/not found - API may be unavailable
		t.Logf("Queried 1 CVE, checked %d", result.CVEsChecked)
	})

	t.Run("multiple CVEs", func(t *testing.T) {
		cves := []string{"CVE-2024-0001", "CVE-2023-0001"}
		result := CheckVulnerabilityIntel(ctx, cves)
		if result == nil {
			t.Fatal("Result should not be nil")
		}
		if result.CVEsChecked != 2 {
			t.Errorf("CVEsChecked = %d, want 2", result.CVEsChecked)
		}
	})
}

func TestCVEIDValidation(t *testing.T) {
	tests := []struct {
		name  string
		cveID string
		valid bool
	}{
		{"valid format", "CVE-2024-1234", true},
		{"valid old format", "CVE-2023-0001", true},
		{"invalid no year", "CVE-1234", false},
		{"invalid no CVE prefix", "2024-1234", false},
		{"empty", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Basic validation - CVE ID should start with "CVE-" and have year
			hasPrefix := len(tt.cveID) > 4 && tt.cveID[:4] == "CVE-"
			hasYear := len(tt.cveID) > 8

			valid := hasPrefix && hasYear
			if valid != tt.valid {
				t.Errorf("CVE %q validation = %v, want %v", tt.cveID, valid, tt.valid)
			}
		})
	}
}

func TestCVESourceEnum(t *testing.T) {
	sources := []string{"CISA_KEV", "NVD", "EUVD"}

	for _, source := range sources {
		if source == "" {
			t.Errorf("Source %q is empty", source)
		}
	}
}

func TestVulnerabilitySeverityLevels(t *testing.T) {
	severities := []string{"CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"}

	for _, severity := range severities {
		if severity == "" {
			t.Error("Severity level is empty")
		}
	}
}

func TestCVSSScoreRange(t *testing.T) {
	tests := []struct {
		name     string
		score    float64
		severity string
	}{
		{"critical", 9.5, "CRITICAL"},
		{"high", 7.5, "HIGH"},
		{"medium", 5.0, "MEDIUM"},
		{"low", 2.0, "LOW"},
		{"none", 0.0, "NONE"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.score < 0 || tt.score > 10 {
				t.Errorf("Invalid CVSS score: %f (must be 0-10)", tt.score)
			}
		})
	}
}
