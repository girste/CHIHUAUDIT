package scanners

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestCheckVulnerabilityIntel_EmptyInput(t *testing.T) {
	result := CheckVulnerabilityIntel(context.Background(), []string{})

	if result.ScanCompleted {
		t.Error("ScanCompleted should be false for empty input")
	}

	if result.Error == "" {
		t.Error("Error should be set for empty input")
	}
}

func TestCheckVulnerabilityIntel_InvalidCVE(t *testing.T) {
	result := CheckVulnerabilityIntel(context.Background(), []string{"invalid", "not-a-cve"})

	if result.ScanCompleted {
		t.Error("ScanCompleted should be false for invalid CVEs")
	}

	if !strings.Contains(result.Error, "No valid CVE IDs") {
		t.Errorf("Error should mention invalid format, got: %s", result.Error)
	}
}

func TestCheckVulnerabilityIntel_ValidCVEFormat(t *testing.T) {
	// This test validates CVE format parsing
	validCVEs := []string{
		"CVE-2024-1234",
		"cve-2023-5678", // lowercase
		"CVE-2020-12345",
		"  CVE-2021-9999  ", // with whitespace
	}

	// Create mock servers to avoid real API calls
	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately to prevent real API calls

	result := CheckVulnerabilityIntel(ctx, validCVEs)

	// Even with cancelled context, it should parse CVEs correctly
	if result.CVEsChecked > 4 {
		t.Errorf("CVEsChecked = %d, expected <= 4", result.CVEsChecked)
	}
}

func TestCheckVulnerabilityIntel_Limit20(t *testing.T) {
	// Test that more than 20 CVEs gets limited
	cves := make([]string, 30)
	for i := 0; i < 30; i++ {
		cves[i] = "CVE-2024-" + strings.Repeat("1", 4+i%5)[:4]
	}

	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	result := CheckVulnerabilityIntel(ctx, cves)

	// Results should be limited to 20
	if len(result.Results) > 20 {
		t.Errorf("Results should be limited to 20, got %d", len(result.Results))
	}
}

func TestCVEIntelResult_Sources(t *testing.T) {
	// Test that Sources field is populated
	result := CVEIntelResult{
		CVEID:   "CVE-2024-1234",
		Found:   true,
		Sources: []string{"CISA KEV", "EUVD", "NVD"},
	}

	if len(result.Sources) != 3 {
		t.Errorf("Sources should have 3 items, got %d", len(result.Sources))
	}
}

func TestVulnIntelSummary_SourcesUsed(t *testing.T) {
	summary := VulnIntelSummary{
		TotalChecked:     5,
		ExploitedInWild:  2,
		InCISAKEV:        2,
		InEUVD:           3,
		CriticalCount:    1,
		HighCount:        2,
		RequireImmediate: 2,
		SourcesUsed:      []string{"CISA KEV", "EUVD (EU)", "NVD"},
	}

	if len(summary.SourcesUsed) != 3 {
		t.Errorf("SourcesUsed should have 3 items, got %d", len(summary.SourcesUsed))
	}

	if summary.InEUVD != 3 {
		t.Errorf("InEUVD = %d, want 3", summary.InEUVD)
	}
}

func TestEUVDSearchResponse_Unmarshal(t *testing.T) {
	jsonData := `{
		"content": [
			{
				"id": "EUVD-2024-1234",
				"cveId": "CVE-2024-1234",
				"description": "Test vulnerability",
				"baseScore": 9.8,
				"baseSeverity": "CRITICAL",
				"epssScore": 0.95,
				"exploited": true
			}
		],
		"totalElements": 1,
		"totalPages": 1,
		"numberOfElements": 1
	}`

	var response euvdSearchResponse
	err := json.Unmarshal([]byte(jsonData), &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if len(response.Content) != 1 {
		t.Fatalf("Expected 1 content item, got %d", len(response.Content))
	}

	vuln := response.Content[0]
	if vuln.CVEID != "CVE-2024-1234" {
		t.Errorf("CVEID = %s, want CVE-2024-1234", vuln.CVEID)
	}

	if vuln.BaseScore != 9.8 {
		t.Errorf("BaseScore = %f, want 9.8", vuln.BaseScore)
	}

	if !vuln.Exploited {
		t.Error("Exploited should be true")
	}

	if vuln.EPSSScore != 0.95 {
		t.Errorf("EPSSScore = %f, want 0.95", vuln.EPSSScore)
	}
}

func TestCISAKEVResponse_Unmarshal(t *testing.T) {
	jsonData := `{
		"catalogVersion": "2024.01.01",
		"dateReleased": "2024-01-01",
		"vulnerabilities": [
			{
				"cveID": "CVE-2024-1234",
				"vendorProject": "Test Vendor",
				"product": "Test Product",
				"vulnerabilityName": "Test Vulnerability",
				"dateAdded": "2024-01-01",
				"shortDescription": "A test vulnerability",
				"requiredAction": "Apply update",
				"dueDate": "2024-01-15"
			}
		]
	}`

	var response cisaKEVResponse
	err := json.Unmarshal([]byte(jsonData), &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if len(response.Vulnerabilities) != 1 {
		t.Fatalf("Expected 1 vulnerability, got %d", len(response.Vulnerabilities))
	}

	vuln := response.Vulnerabilities[0]
	if vuln.CVEID != "CVE-2024-1234" {
		t.Errorf("CVEID = %s, want CVE-2024-1234", vuln.CVEID)
	}

	if vuln.RequiredAction != "Apply update" {
		t.Errorf("RequiredAction = %s, want 'Apply update'", vuln.RequiredAction)
	}
}

func TestNVDResponse_Unmarshal(t *testing.T) {
	jsonData := `{
		"vulnerabilities": [
			{
				"cve": {
					"id": "CVE-2024-1234",
					"descriptions": {
						"descriptions": [
							{"lang": "en", "value": "Test description"}
						]
					},
					"metrics": {
						"cvssMetricV31": [
							{
								"cvssData": {
									"baseScore": 8.5,
									"baseSeverity": "HIGH"
								}
							}
						]
					},
					"references": [
						{"url": "https://example.com/advisory"}
					]
				}
			}
		]
	}`

	var response nvdResponse
	err := json.Unmarshal([]byte(jsonData), &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if len(response.Vulnerabilities) != 1 {
		t.Fatalf("Expected 1 vulnerability, got %d", len(response.Vulnerabilities))
	}

	cve := response.Vulnerabilities[0].CVE
	if cve.ID != "CVE-2024-1234" {
		t.Errorf("ID = %s, want CVE-2024-1234", cve.ID)
	}

	if len(cve.Metrics.CVSSMetricV31) != 1 {
		t.Fatalf("Expected 1 CVSS metric")
	}

	if cve.Metrics.CVSSMetricV31[0].CVSSData.BaseScore != 8.5 {
		t.Errorf("BaseScore = %f, want 8.5", cve.Metrics.CVSSMetricV31[0].CVSSData.BaseScore)
	}
}

func TestFetchCISAKEV_MockServer(t *testing.T) {
	// Create mock CISA KEV server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		response := cisaKEVResponse{
			CatalogVersion: "2024.01.01",
			Vulnerabilities: []cisaKEVVuln{
				{
					CVEID:            "CVE-2024-1234",
					VendorProject:    "Test",
					Product:          "Test Product",
					DateAdded:        "2024-01-01",
					ShortDescription: "Test vulnerability",
					RequiredAction:   "Apply patches",
					DueDate:          "2024-01-15",
				},
			},
		}
		w.Header().Set("Content-Type", "application/json")
		_ = json.NewEncoder(w).Encode(response) // Test mock - error ignored
		// For now, we just verify the response structure is correct
	}))
	defer server.Close()

	t.Skip("Skipping mock server test - requires URL injection")
}

func TestRecommendation_Generation(t *testing.T) {
	tests := []struct {
		name         string
		exploited    bool
		epss         float64
		severity     string
		cvss         float64
		wantContains string
	}{
		{
			name:         "exploited_urgent",
			exploited:    true,
			wantContains: "URGENT",
		},
		{
			name:         "high_epss",
			exploited:    false,
			epss:         0.6,
			wantContains: "HIGH RISK",
		},
		{
			name:         "critical_severity",
			exploited:    false,
			epss:         0.1,
			severity:     "critical",
			wantContains: "24-48 hours",
		},
		{
			name:         "high_cvss",
			exploited:    false,
			epss:         0.1,
			cvss:         9.5,
			wantContains: "24-48 hours",
		},
		{
			name:         "high_severity",
			exploited:    false,
			epss:         0.1,
			severity:     "high",
			wantContains: "1 week",
		},
		{
			name:         "medium_cvss",
			exploited:    false,
			epss:         0.1,
			cvss:         7.5,
			wantContains: "1 week",
		},
		{
			name:         "low_priority",
			exploited:    false,
			epss:         0.1,
			severity:     "medium",
			cvss:         5.0,
			wantContains: "regular patching",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CVEIntelResult{
				CVEID:           "CVE-2024-TEST",
				Found:           true,
				ExploitedInWild: tt.exploited,
				EPSSScore:       tt.epss,
				Severity:        tt.severity,
				CVSSScore:       tt.cvss,
			}

			// Generate recommendation
			rec := ""
			if result.ExploitedInWild {
				rec = "URGENT: This vulnerability is actively exploited. Patch immediately."
			} else if result.EPSSScore > 0.5 {
				rec = "HIGH RISK: EPSS score indicates high exploitation probability. Patch within 24 hours."
			} else if result.Severity == "critical" || result.CVSSScore >= 9.0 {
				rec = "High priority: Patch within 24-48 hours"
			} else if result.Severity == "high" || result.CVSSScore >= 7.0 {
				rec = "Medium priority: Patch within 1 week"
			} else {
				rec = "Low priority: Include in regular patching cycle"
			}

			if !strings.Contains(rec, tt.wantContains) {
				t.Errorf("Recommendation = %q, want to contain %q", rec, tt.wantContains)
			}
		})
	}
}
