package scanners

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"
)

const (
	cisaKEVURL  = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
	nvdAPIURL   = "https://services.nvd.nist.gov/rest/json/cves/2.0"
	httpTimeout = 30 * time.Second
)

// VulnerabilityIntelResult is the result of vulnerability intelligence check
type VulnerabilityIntelResult struct {
	ScanCompleted bool             `json:"scan_completed"`
	CVEsChecked   int              `json:"cves_checked"`
	Results       []CVEIntelResult `json:"results"`
	Summary       VulnIntelSummary `json:"summary"`
	Error         string           `json:"error,omitempty"`
}

type CVEIntelResult struct {
	CVEID           string   `json:"cve_id"`
	Found           bool     `json:"found"`
	InKEV           bool     `json:"in_kev"`
	KEVDateAdded    string   `json:"kev_date_added,omitempty"`
	KEVDueDate      string   `json:"kev_due_date,omitempty"`
	ExploitedInWild bool     `json:"exploited_in_wild"`
	Severity        string   `json:"severity,omitempty"`
	CVSSScore       float64  `json:"cvss_score,omitempty"`
	Description     string   `json:"description,omitempty"`
	References      []string `json:"references,omitempty"`
	Recommendation  string   `json:"recommendation,omitempty"`
}

type VulnIntelSummary struct {
	TotalChecked     int `json:"total_checked"`
	ExploitedInWild  int `json:"exploited_in_wild"`
	InCISAKEV        int `json:"in_cisa_kev"`
	CriticalCount    int `json:"critical_count"`
	HighCount        int `json:"high_count"`
	RequireImmediate int `json:"require_immediate_action"`
}

// CISA KEV response structure
type cisaKEVResponse struct {
	CatalogVersion  string        `json:"catalogVersion"`
	DateReleased    string        `json:"dateReleased"`
	Vulnerabilities []cisaKEVVuln `json:"vulnerabilities"`
}

type cisaKEVVuln struct {
	CVEID             string `json:"cveID"`
	VendorProject     string `json:"vendorProject"`
	Product           string `json:"product"`
	VulnerabilityName string `json:"vulnerabilityName"`
	DateAdded         string `json:"dateAdded"`
	ShortDescription  string `json:"shortDescription"`
	RequiredAction    string `json:"requiredAction"`
	DueDate           string `json:"dueDate"`
}

// NVD response structure (simplified)
type nvdResponse struct {
	Vulnerabilities []struct {
		CVE struct {
			ID          string `json:"id"`
			Description struct {
				Descriptions []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
			} `json:"descriptions"`
			Metrics struct {
				CVSSMetricV31 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV31"`
				CVSSMetricV30 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV30"`
			} `json:"metrics"`
			References []struct {
				URL string `json:"url"`
			} `json:"references"`
		} `json:"cve"`
	} `json:"vulnerabilities"`
}

// CheckVulnerabilityIntel checks CVEs against threat intelligence sources
func CheckVulnerabilityIntel(ctx context.Context, cveIDs []string) *VulnerabilityIntelResult {
	if len(cveIDs) == 0 {
		return &VulnerabilityIntelResult{
			ScanCompleted: false,
			Error:         "No CVE IDs provided",
		}
	}

	// Validate CVE IDs
	cvePattern := regexp.MustCompile(`^CVE-\d{4}-\d+$`)
	var validCVEs []string
	for _, cve := range cveIDs {
		cve = strings.TrimSpace(strings.ToUpper(cve))
		if cvePattern.MatchString(cve) {
			validCVEs = append(validCVEs, cve)
		}
	}

	if len(validCVEs) == 0 {
		return &VulnerabilityIntelResult{
			ScanCompleted: false,
			Error:         "No valid CVE IDs provided (format: CVE-YYYY-NNNNN)",
		}
	}

	// Limit to 20 CVEs per request
	if len(validCVEs) > 20 {
		validCVEs = validCVEs[:20]
	}

	result := &VulnerabilityIntelResult{
		ScanCompleted: true,
		CVEsChecked:   len(validCVEs),
		Results:       []CVEIntelResult{},
	}

	// Fetch CISA KEV catalog
	kevCatalog := fetchCISAKEV(ctx)

	// Check each CVE
	for _, cveID := range validCVEs {
		cveResult := CVEIntelResult{
			CVEID: cveID,
			Found: false,
		}

		// Check CISA KEV
		if kevEntry, ok := kevCatalog[cveID]; ok {
			cveResult.Found = true
			cveResult.InKEV = true
			cveResult.ExploitedInWild = true
			cveResult.KEVDateAdded = kevEntry.DateAdded
			cveResult.KEVDueDate = kevEntry.DueDate
			cveResult.Description = kevEntry.ShortDescription
			cveResult.Recommendation = kevEntry.RequiredAction
			cveResult.Severity = "critical" // KEV entries are always high priority
		}

		// Fetch from NVD
		nvdData := fetchNVD(ctx, cveID)
		if nvdData != nil {
			cveResult.Found = true
			if nvdData.Severity != "" {
				cveResult.Severity = nvdData.Severity
			}
			if nvdData.CVSSScore > 0 {
				cveResult.CVSSScore = nvdData.CVSSScore
			}
			if nvdData.Description != "" && cveResult.Description == "" {
				cveResult.Description = nvdData.Description
			}
			cveResult.References = nvdData.References
		}

		// Generate recommendation if not from KEV
		if cveResult.Recommendation == "" && cveResult.Found {
			if cveResult.ExploitedInWild {
				cveResult.Recommendation = "URGENT: This vulnerability is actively exploited. Patch immediately."
			} else if cveResult.Severity == "critical" || cveResult.CVSSScore >= 9.0 {
				cveResult.Recommendation = "High priority: Patch within 24-48 hours"
			} else if cveResult.Severity == "high" || cveResult.CVSSScore >= 7.0 {
				cveResult.Recommendation = "Medium priority: Patch within 1 week"
			} else {
				cveResult.Recommendation = "Low priority: Include in regular patching cycle"
			}
		}

		result.Results = append(result.Results, cveResult)
	}

	// Calculate summary
	for _, r := range result.Results {
		if r.ExploitedInWild {
			result.Summary.ExploitedInWild++
			result.Summary.RequireImmediate++
		}
		if r.InKEV {
			result.Summary.InCISAKEV++
		}
		switch strings.ToLower(r.Severity) {
		case "critical":
			result.Summary.CriticalCount++
		case "high":
			result.Summary.HighCount++
		}
	}
	result.Summary.TotalChecked = len(result.Results)

	return result
}

func fetchCISAKEV(ctx context.Context) map[string]cisaKEVVuln {
	catalog := make(map[string]cisaKEVVuln)

	client := &http.Client{Timeout: httpTimeout}
	req, err := http.NewRequestWithContext(ctx, "GET", cisaKEVURL, nil)
	if err != nil {
		return catalog
	}

	resp, err := client.Do(req)
	if err != nil {
		return catalog
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return catalog
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return catalog
	}

	var kevData cisaKEVResponse
	if err := json.Unmarshal(body, &kevData); err != nil {
		return catalog
	}

	for _, vuln := range kevData.Vulnerabilities {
		catalog[vuln.CVEID] = vuln
	}

	return catalog
}

type nvdCVEData struct {
	Severity    string
	CVSSScore   float64
	Description string
	References  []string
}

func fetchNVD(ctx context.Context, cveID string) *nvdCVEData {
	client := &http.Client{Timeout: httpTimeout}
	url := fmt.Sprintf("%s?cveId=%s", nvdAPIURL, cveID)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil
	}

	var nvdData nvdResponse
	if err := json.Unmarshal(body, &nvdData); err != nil {
		return nil
	}

	if len(nvdData.Vulnerabilities) == 0 {
		return nil
	}

	cve := nvdData.Vulnerabilities[0].CVE
	result := &nvdCVEData{}

	// Get description
	for _, desc := range cve.Description.Descriptions {
		if desc.Lang == "en" {
			result.Description = desc.Value
			break
		}
	}

	// Get CVSS score (prefer v3.1, then v3.0)
	if len(cve.Metrics.CVSSMetricV31) > 0 {
		result.CVSSScore = cve.Metrics.CVSSMetricV31[0].CVSSData.BaseScore
		result.Severity = strings.ToLower(cve.Metrics.CVSSMetricV31[0].CVSSData.BaseSeverity)
	} else if len(cve.Metrics.CVSSMetricV30) > 0 {
		result.CVSSScore = cve.Metrics.CVSSMetricV30[0].CVSSData.BaseScore
		result.Severity = strings.ToLower(cve.Metrics.CVSSMetricV30[0].CVSSData.BaseSeverity)
	}

	// Get references (limit to 5)
	for i, ref := range cve.References {
		if i >= 5 {
			break
		}
		result.References = append(result.References, ref.URL)
	}

	return result
}
