package scanners

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"
)

const (
	cisaKEVURL  = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
	nvdAPIURL   = "https://services.nvd.nist.gov/rest/json/cves/2.0"
	euvdAPIURL  = "https://euvdservices.enisa.europa.eu/api"
	httpTimeout = 30 * time.Second
)

// VulnerabilityIntelResult is the result of vulnerability intelligence check
type VulnerabilityIntelResult struct {
	ScanCompleted bool             `json:"scan_completed"`
	CVEsChecked   int              `json:"cves_checked"`
	Results       []CVEIntelResult `json:"results"`
	Summary       VulnIntelSummary `json:"summary"`
	Error         string           `json:"error,omitempty"`
}

type CVEIntelResult struct {
	CVEID           string   `json:"cve_id"`
	Found           bool     `json:"found"`
	InKEV           bool     `json:"in_kev"`
	KEVDateAdded    string   `json:"kev_date_added,omitempty"`
	KEVDueDate      string   `json:"kev_due_date,omitempty"`
	InEUVD          bool     `json:"in_euvd"`
	EUVDExploited   bool     `json:"euvd_exploited,omitempty"`
	EUVDID          string   `json:"euvd_id,omitempty"`
	EPSSScore       float64  `json:"epss_score,omitempty"`
	ExploitedInWild bool     `json:"exploited_in_wild"`
	Severity        string   `json:"severity,omitempty"`
	CVSSScore       float64  `json:"cvss_score,omitempty"`
	Description     string   `json:"description,omitempty"`
	References      []string `json:"references,omitempty"`
	Recommendation  string   `json:"recommendation,omitempty"`
	Sources         []string `json:"sources"`
}

type VulnIntelSummary struct {
	TotalChecked     int      `json:"total_checked"`
	ExploitedInWild  int      `json:"exploited_in_wild"`
	InCISAKEV        int      `json:"in_cisa_kev"`
	InEUVD           int      `json:"in_euvd"`
	CriticalCount    int      `json:"critical_count"`
	HighCount        int      `json:"high_count"`
	RequireImmediate int      `json:"require_immediate_action"`
	SourcesUsed      []string `json:"sources_used"`
}

// CISA KEV response structure
type cisaKEVResponse struct {
	CatalogVersion  string        `json:"catalogVersion"`
	DateReleased    string        `json:"dateReleased"`
	Vulnerabilities []cisaKEVVuln `json:"vulnerabilities"`
}

type cisaKEVVuln struct {
	CVEID             string `json:"cveID"`
	VendorProject     string `json:"vendorProject"`
	Product           string `json:"product"`
	VulnerabilityName string `json:"vulnerabilityName"`
	DateAdded         string `json:"dateAdded"`
	ShortDescription  string `json:"shortDescription"`
	RequiredAction    string `json:"requiredAction"`
	DueDate           string `json:"dueDate"`
}

// NVD response structure (simplified)
type nvdResponse struct {
	Vulnerabilities []struct {
		CVE struct {
			ID          string `json:"id"`
			Description struct {
				Descriptions []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
			} `json:"descriptions"`
			Metrics struct {
				CVSSMetricV31 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV31"`
				CVSSMetricV30 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV30"`
			} `json:"metrics"`
			References []struct {
				URL string `json:"url"`
			} `json:"references"`
		} `json:"cve"`
	} `json:"vulnerabilities"`
}

// EUVD (European Vulnerability Database) response structures
type euvdSearchResponse struct {
	Content          []euvdVulnerability `json:"content"`
	TotalElements    int                 `json:"totalElements"`
	TotalPages       int                 `json:"totalPages"`
	NumberOfElements int                 `json:"numberOfElements"`
}

type euvdVulnerability struct {
	ID               string   `json:"id"`
	CVEID            string   `json:"cveId"`
	Description      string   `json:"description"`
	DatePublished    string   `json:"datePublished"`
	DateUpdated      string   `json:"dateUpdated"`
	BaseScore        float64  `json:"baseScore"`
	BaseSeverity     string   `json:"baseSeverity"`
	EPSSScore        float64  `json:"epssScore"`
	Exploited        bool     `json:"exploited"`
	Vendor           string   `json:"vendor"`
	Product          string   `json:"product"`
	AffectedVersions []string `json:"affectedVersions"`
}

// CheckVulnerabilityIntel checks CVEs against threat intelligence sources
func CheckVulnerabilityIntel(ctx context.Context, cveIDs []string) *VulnerabilityIntelResult {
	if len(cveIDs) == 0 {
		return &VulnerabilityIntelResult{
			ScanCompleted: false,
			Error:         "No CVE IDs provided",
		}
	}

	// Validate CVE IDs
	cvePattern := regexp.MustCompile(`^CVE-\d{4}-\d+$`)
	var validCVEs []string
	for _, cve := range cveIDs {
		cve = strings.TrimSpace(strings.ToUpper(cve))
		if cvePattern.MatchString(cve) {
			validCVEs = append(validCVEs, cve)
		}
	}

	if len(validCVEs) == 0 {
		return &VulnerabilityIntelResult{
			ScanCompleted: false,
			Error:         "No valid CVE IDs provided (format: CVE-YYYY-NNNNN)",
		}
	}

	// Limit to 20 CVEs per request
	if len(validCVEs) > 20 {
		validCVEs = validCVEs[:20]
	}

	result := &VulnerabilityIntelResult{
		ScanCompleted: true,
		CVEsChecked:   len(validCVEs),
		Results:       []CVEIntelResult{},
	}

	// Track sources used
	sourcesUsed := []string{}

	// Fetch CISA KEV catalog
	kevCatalog := fetchCISAKEV(ctx)
	if len(kevCatalog) > 0 {
		sourcesUsed = append(sourcesUsed, "CISA KEV")
	}

	// Fetch EUVD data for all CVEs (batch query)
	euvdData := fetchEUVDBatch(ctx, validCVEs)
	if len(euvdData) > 0 {
		sourcesUsed = append(sourcesUsed, "EUVD (EU)")
	}

	// Check each CVE
	for _, cveID := range validCVEs {
		cveResult := CVEIntelResult{
			CVEID:   cveID,
			Found:   false,
			Sources: []string{},
		}

		// Check CISA KEV
		if kevEntry, ok := kevCatalog[cveID]; ok {
			cveResult.Found = true
			cveResult.InKEV = true
			cveResult.ExploitedInWild = true
			cveResult.KEVDateAdded = kevEntry.DateAdded
			cveResult.KEVDueDate = kevEntry.DueDate
			cveResult.Description = kevEntry.ShortDescription
			cveResult.Recommendation = kevEntry.RequiredAction
			cveResult.Severity = "critical" // KEV entries are always high priority
			cveResult.Sources = append(cveResult.Sources, "CISA KEV")
		}

		// Check EUVD (European Vulnerability Database)
		if euvdEntry, ok := euvdData[cveID]; ok {
			cveResult.Found = true
			cveResult.InEUVD = true
			cveResult.EUVDID = euvdEntry.ID
			cveResult.EUVDExploited = euvdEntry.Exploited
			cveResult.Sources = append(cveResult.Sources, "EUVD")

			// Use EUVD data if not already set
			if euvdEntry.EPSSScore > 0 {
				cveResult.EPSSScore = euvdEntry.EPSSScore
			}
			if euvdEntry.Exploited && !cveResult.ExploitedInWild {
				cveResult.ExploitedInWild = true
			}
			if euvdEntry.BaseSeverity != "" && cveResult.Severity == "" {
				cveResult.Severity = strings.ToLower(euvdEntry.BaseSeverity)
			}
			if euvdEntry.BaseScore > 0 && cveResult.CVSSScore == 0 {
				cveResult.CVSSScore = euvdEntry.BaseScore
			}
			if euvdEntry.Description != "" && cveResult.Description == "" {
				cveResult.Description = euvdEntry.Description
			}
		}

		// Fetch from NVD (US National Vulnerability Database)
		nvdData := fetchNVD(ctx, cveID)
		if nvdData != nil {
			cveResult.Found = true
			cveResult.Sources = append(cveResult.Sources, "NVD")
			if nvdData.Severity != "" && cveResult.Severity == "" {
				cveResult.Severity = nvdData.Severity
			}
			if nvdData.CVSSScore > 0 && cveResult.CVSSScore == 0 {
				cveResult.CVSSScore = nvdData.CVSSScore
			}
			if nvdData.Description != "" && cveResult.Description == "" {
				cveResult.Description = nvdData.Description
			}
			if len(nvdData.References) > 0 && len(cveResult.References) == 0 {
				cveResult.References = nvdData.References
			}
		}

		// Generate recommendation if not from KEV
		if cveResult.Recommendation == "" && cveResult.Found {
			if cveResult.ExploitedInWild {
				cveResult.Recommendation = "URGENT: This vulnerability is actively exploited. Patch immediately."
			} else if cveResult.EPSSScore > 0.5 {
				cveResult.Recommendation = "HIGH RISK: EPSS score indicates high exploitation probability. Patch within 24 hours."
			} else if cveResult.Severity == "critical" || cveResult.CVSSScore >= 9.0 {
				cveResult.Recommendation = "High priority: Patch within 24-48 hours"
			} else if cveResult.Severity == "high" || cveResult.CVSSScore >= 7.0 {
				cveResult.Recommendation = "Medium priority: Patch within 1 week"
			} else {
				cveResult.Recommendation = "Low priority: Include in regular patching cycle"
			}
		}

		result.Results = append(result.Results, cveResult)
	}

	result.Summary.SourcesUsed = sourcesUsed

	// Calculate summary
	for _, r := range result.Results {
		if r.ExploitedInWild {
			result.Summary.ExploitedInWild++
			result.Summary.RequireImmediate++
		}
		if r.InKEV {
			result.Summary.InCISAKEV++
		}
		if r.InEUVD {
			result.Summary.InEUVD++
		}
		switch strings.ToLower(r.Severity) {
		case "critical":
			result.Summary.CriticalCount++
		case "high":
			result.Summary.HighCount++
		}
	}
	result.Summary.TotalChecked = len(result.Results)

	return result
}

// fetchEUVDBatch fetches vulnerability data from EUVD for multiple CVEs
func fetchEUVDBatch(ctx context.Context, cveIDs []string) map[string]euvdVulnerability {
	results := make(map[string]euvdVulnerability)

	client := &http.Client{Timeout: httpTimeout}

	for _, cveID := range cveIDs {
		// EUVD search endpoint by CVE ID
		url := fmt.Sprintf("%s/search?text=%s&page=0&size=1", euvdAPIURL, cveID)

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			continue
		}
		req.Header.Set("Accept", "application/json")

		resp, err := client.Do(req)
		if err != nil {
			continue
		}

		if resp.StatusCode != http.StatusOK {
			_ = resp.Body.Close()
			continue
		}

		body, err := io.ReadAll(resp.Body)
		_ = resp.Body.Close()
		if err != nil {
			continue
		}

		var searchResp euvdSearchResponse
		if err := json.Unmarshal(body, &searchResp); err != nil {
			continue
		}

		// Find matching CVE in response
		for _, vuln := range searchResp.Content {
			if vuln.CVEID == cveID {
				results[cveID] = vuln
				break
			}
		}
	}

	return results
}

func fetchCISAKEV(ctx context.Context) map[string]cisaKEVVuln {
	catalog := make(map[string]cisaKEVVuln)

	client := &http.Client{Timeout: httpTimeout}
	req, err := http.NewRequestWithContext(ctx, "GET", cisaKEVURL, nil)
	if err != nil {
		return catalog
	}

	resp, err := client.Do(req)
	if err != nil {
		return catalog
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return catalog
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return catalog
	}

	var kevData cisaKEVResponse
	if err := json.Unmarshal(body, &kevData); err != nil {
		return catalog
	}

	for _, vuln := range kevData.Vulnerabilities {
		catalog[vuln.CVEID] = vuln
	}

	return catalog
}

type nvdCVEData struct {
	Severity    string
	CVSSScore   float64
	Description string
	References  []string
}

func fetchNVD(ctx context.Context, cveID string) *nvdCVEData {
	client := &http.Client{Timeout: httpTimeout}
	url := fmt.Sprintf("%s?cveId=%s", nvdAPIURL, cveID)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil
	}

	var nvdData nvdResponse
	if err := json.Unmarshal(body, &nvdData); err != nil {
		return nil
	}

	if len(nvdData.Vulnerabilities) == 0 {
		return nil
	}

	cve := nvdData.Vulnerabilities[0].CVE
	result := &nvdCVEData{}

	// Get description
	for _, desc := range cve.Description.Descriptions {
		if desc.Lang == "en" {
			result.Description = desc.Value
			break
		}
	}

	// Get CVSS score (prefer v3.1, then v3.0)
	if len(cve.Metrics.CVSSMetricV31) > 0 {
		result.CVSSScore = cve.Metrics.CVSSMetricV31[0].CVSSData.BaseScore
		result.Severity = strings.ToLower(cve.Metrics.CVSSMetricV31[0].CVSSData.BaseSeverity)
	} else if len(cve.Metrics.CVSSMetricV30) > 0 {
		result.CVSSScore = cve.Metrics.CVSSMetricV30[0].CVSSData.BaseScore
		result.Severity = strings.ToLower(cve.Metrics.CVSSMetricV30[0].CVSSData.BaseSeverity)
	}

	// Get references (limit to 5)
	for i, ref := range cve.References {
		if i >= 5 {
			break
		}
		result.References = append(result.References, ref.URL)
	}

	return result
}
