package mcp

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/girste/chihuaudit/internal/audit"
	"github.com/girste/chihuaudit/internal/cis"
	"github.com/girste/chihuaudit/internal/config"
	"github.com/girste/chihuaudit/internal/metrics"
	"github.com/girste/chihuaudit/internal/monitoring"
	"github.com/girste/chihuaudit/internal/notify"
	"github.com/girste/chihuaudit/internal/output"
	"github.com/girste/chihuaudit/internal/scanners"
	"github.com/girste/chihuaudit/internal/util"
	"github.com/google/uuid"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"go.uber.org/zap"
)

// Server wraps the MCP server
type Server struct {
	mcp           *server.MCPServer
	orchestrator  *audit.Orchestrator
	config        *config.Config
	preloadedData map[string]interface{} // For serve mode (no sudo)
	logger        *zap.Logger
	metricsReg    *metrics.Registry
}

// NewServer creates a new MCP server
func NewServer() (*Server, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}

	logger := util.GetLogger()
	metricsReg := metrics.GetRegistry()

	// Start metrics HTTP server on localhost only (non-blocking)
	if err := metrics.StartServer("127.0.0.1:9090", metricsReg); err != nil {
		logger.Warn("Failed to start metrics server", zap.Error(err))
	} else {
		logger.Info("Metrics server started", zap.String("addr", "http://127.0.0.1:9090"))
	}

	mcpServer := server.NewMCPServer(
		"chihuaudit",
		"1.0.0",
		server.WithLogging(),
	)

	s := &Server{
		mcp:          mcpServer,
		orchestrator: audit.NewOrchestrator(),
		config:       cfg,
		logger:       logger,
		metricsReg:   metricsReg,
	}

	s.registerTools()

	logger.Info("MCP server initialized", zap.String("version", "1.0.0"))

	return s, nil
}

// NewServerWithData creates MCP server with pre-loaded audit data (no sudo mode)
func NewServerWithData(auditData map[string]interface{}) (*Server, error) {
	cfg, err := config.Load()
	if err != nil {
		// Non-critical in serve mode
		cfg = &config.Config{}
	}

	logger := util.GetLogger()

	mcpServer := server.NewMCPServer(
		"chihuaudit",
		"1.0.0",
		server.WithLogging(),
	)

	s := &Server{
		mcp:           mcpServer,
		config:        cfg,
		preloadedData: auditData,
		logger:        logger,
		// orchestrator intentionally nil (serve mode doesn't audit)
	}

	s.registerTools()

	logger.Info("MCP server initialized in serve mode", zap.Bool("preloaded", auditData != nil))

	return s, nil
}

func (s *Server) registerTools() {
	// Security audit tool
	s.mcp.AddTool(mcp.Tool{
		Name:        "security_audit",
		Description: "Run comprehensive cybersecurity audit of the Linux server. Analyzes: firewall (ufw/iptables/firewalld), SSH configuration, threat patterns, fail2ban, network services/open ports, Docker security, security updates, MAC (AppArmor/SELinux), and kernel hardening. Returns detailed JSON report with security score and actionable recommendations.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"mask_data": map[string]interface{}{
					"type":        "boolean",
					"description": "Mask sensitive data like IPs and hostname (default: true)",
					"default":     true,
				},
			},
		},
	}, s.handleSecurityAudit)

	// Analyze anomaly
	s.mcp.AddTool(mcp.Tool{
		Name:        "analyze_anomaly",
		Description: "Analyze security anomaly with AI-powered insights. Use this when the monitoring system detects anomalies (firewall changes, new open ports, SSH config changes, attack spikes, etc.). Provides deep analysis of what changed, why it's concerning, and recommended actions. This tool should ONLY be called when anomalies are detected - don't waste tokens on normal state.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"anomaly_file": map[string]interface{}{
					"type":        "string",
					"description": "Path to anomaly report JSON file (generated by monitor)",
				},
			},
			Required: []string{"anomaly_file"},
		},
	}, s.handleAnalyzeAnomaly)

	// Monitoring status
	s.mcp.AddTool(mcp.Tool{
		Name:        "monitoring_status",
		Description: "Get current status of security monitoring daemon. Shows if monitoring is running, how many logs collected, disk usage, etc. Use this to check monitoring state before starting/stopping it.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleMonitoringStatus)

	// Start monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "start_monitoring",
		Description: "Start continuous security monitoring in background. The daemon will check security state periodically and alert on anomalies. IMPORTANT: Ask user for confirmation before starting! This runs a background process.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"interval_seconds": map[string]interface{}{
					"type":        "number",
					"description": "Check interval in seconds (default: 3600 = 1 hour, min: 10, max: 86400 = 24 hours)",
					"default":     3600,
				},
			},
		},
	}, s.handleStartMonitoring)

	// Stop monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "stop_monitoring",
		Description: "Stop security monitoring daemon. IMPORTANT: Ask user for confirmation before stopping!",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleStopMonitoring)

	// Cleanup old logs
	s.mcp.AddTool(mcp.Tool{
		Name:        "cleanup_old_logs",
		Description: "Remove old monitoring logs to free disk space. Keeps most recent 50 bulletins and 20 anomaly reports, deletes older ones. Safe to run periodically to prevent disk fill.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleCleanupOldLogs)

	// Scan network security
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_network_security",
		Description: "Analyze network security posture and attack surface. LOCAL scope: port bindings, wildcard listeners (0.0.0.0), risky exposed services, IPv6. EXTERNAL scope: public IP detection, open port scan, SSL/TLS analysis, DNS security (SPF/DMARC/CAA). ATTACKER_VIEW: compare local vs external visibility using Shodan InternetDB (free, no API key), check IP reputation. CLOUD_CONTEXT: detect AWS/GCP/Azure and analyze security groups. Use scope='local' for safe internal checks, 'external' for internet-facing analysis, 'both' for complete audit.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"scope": map[string]interface{}{
					"type":        "string",
					"description": "Scan scope: 'local' (safe), 'external' (requires public access), 'both' (complete)",
					"enum":        []string{"local", "external", "both"},
					"default":     "local",
				},
				"deep": map[string]interface{}{
					"type":        "boolean",
					"description": "Enable deep analysis (SSL/TLS ciphers, DNS records) - only for external scope",
					"default":     false,
				},
				"attacker_view": map[string]interface{}{
					"type":        "boolean",
					"description": "Compare local ports vs externally visible ports using Shodan InternetDB. Checks IP reputation via DNSBL. Identifies discrepancies and known vulnerabilities.",
					"default":     false,
				},
				"cloud_context": map[string]interface{}{
					"type":        "boolean",
					"description": "Detect cloud provider (AWS/GCP/Azure/DigitalOcean) via metadata endpoints. Analyze security groups if AWS CLI available. Compare cloud firewall with local listeners.",
					"default":     false,
				},
			},
		},
	}, s.handleScanNetworkSecurity)

	// Verify backup config
	s.mcp.AddTool(mcp.Tool{
		Name:        "verify_backup_config",
		Description: "Audit backup and disaster recovery configuration. Checks: installed backup tools (restic/borg/duplicity), scheduled backups (cron/systemd), backup destinations (local/remote), encryption status, last backup run. DOES NOT perform backups, only verifies configuration for disaster recovery readiness.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleVerifyBackupConfig)

	// Scan database security
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_database_security",
		Description: "Audit database security configuration for running databases. Auto-detects MySQL/MariaDB, PostgreSQL, MongoDB, Redis. Checks: default credentials, weak passwords, remote access (0.0.0.0), authentication disabled, dangerous commands enabled, user privileges. Use db_type='auto' for auto-detection or specify 'mysql', 'postgresql', 'mongodb', 'redis'.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"db_type": map[string]interface{}{
					"type":        "string",
					"description": "Database type: 'auto' (detect all), 'mysql', 'postgresql', 'mongodb', 'redis'",
					"enum":        []string{"auto", "mysql", "postgresql", "mongodb", "redis"},
					"default":     "auto",
				},
			},
		},
	}, s.handleScanDatabaseSecurity)

	// Check vulnerability intel
	s.mcp.AddTool(mcp.Tool{
		Name:        "check_vulnerability_intel",
		Description: "Check if CVEs have known exploits or are actively exploited in the wild. Uses free public APIs: CISA KEV (Known Exploited Vulnerabilities), NVD (National Vulnerability Database). NO registration or API keys required. Identifies critical-risk CVEs that are being actively exploited and require immediate patching.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"cve_ids": map[string]interface{}{
					"type":        "array",
					"items":       map[string]interface{}{"type": "string"},
					"description": "List of CVE IDs to check (e.g., ['CVE-2024-1234', 'CVE-2023-5678'])",
				},
			},
			Required: []string{"cve_ids"},
		},
	}, s.handleCheckVulnerabilityIntel)

	// Scan WAF/CDN detection
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_waf_cdn",
		Description: "Detect WAF (Web Application Firewall) and CDN protection for a domain. Identifies: Cloudflare, AWS CloudFront/WAF, Akamai, Azure CDN/Front Door, Fastly, Imperva/Incapsula, Sucuri, Google Cloud CDN, StackPath, KeyCDN, BunnyCDN, DDoS-Guard. Detection methods: HTTP response headers, DNS CNAME chain analysis, IP range matching, cookie inspection. Returns security posture analysis with protection status and recommendations.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"domain": map[string]interface{}{
					"type":        "string",
					"description": "Domain to analyze (e.g., 'example.com'). Do not include protocol (http/https).",
				},
				"include_headers": map[string]interface{}{
					"type":        "boolean",
					"description": "Include raw HTTP response headers in output for manual inspection (default: false)",
					"default":     false,
				},
			},
			Required: []string{"domain"},
		},
	}, s.handleScanWAFCDN)

	// CIS Benchmark audit
	s.mcp.AddTool(mcp.Tool{
		Name:        "cis_audit",
		Description: "Run CIS Benchmark compliance audit. Currently supports Ubuntu 22.04 LTS Level 1 (60 scored controls). Checks filesystem hardening, network security, logging/auditing, access control, and system maintenance. Returns compliance percentage and detailed control results with remediation guidance.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"level": map[string]interface{}{
					"type":        "integer",
					"description": "CIS Level (1 or 2). Level 1 provides essential security. Level 2 adds defense-in-depth. Currently only Level 1 is implemented. Default: 1",
					"default":     1,
					"enum":        []int{1, 2},
				},
				"include_all_controls": map[string]interface{}{
					"type":        "boolean",
					"description": "Include all controls in output (not just failed). Default: false",
					"default":     false,
				},
			},
		},
	}, s.handleCISAudit)

	// Configure webhook notifications
	s.mcp.AddTool(mcp.Tool{
		Name:        "configure_webhook",
		Description: "Configure webhook notifications for security alerts. Supports Discord, Slack, and generic webhooks. The webhook URL will be saved to the config file. Use this to set up real-time alerts when security issues are detected. IMPORTANT: Ask the user for their webhook URL before calling this tool.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"provider": map[string]interface{}{
					"type":        "string",
					"description": "Webhook provider: 'discord', 'slack', or 'generic'",
					"enum":        []string{"discord", "slack", "generic"},
				},
				"webhook_url": map[string]interface{}{
					"type":        "string",
					"description": "The webhook URL to send notifications to",
				},
				"enabled": map[string]interface{}{
					"type":        "boolean",
					"description": "Enable or disable notifications (default: true)",
					"default":     true,
				},
				"only_on_issues": map[string]interface{}{
					"type":        "boolean",
					"description": "Only send notifications when issues are found (default: true)",
					"default":     true,
				},
				"min_severity": map[string]interface{}{
					"type":        "string",
					"description": "Minimum severity to trigger notifications: 'critical', 'high', 'medium', 'low' (default: 'high')",
					"enum":        []string{"critical", "high", "medium", "low"},
					"default":     "high",
				},
			},
			Required: []string{"provider", "webhook_url"},
		},
	}, s.handleConfigureWebhook)

	// Test webhook
	s.mcp.AddTool(mcp.Tool{
		Name:        "test_webhook",
		Description: "Send a test notification to verify webhook configuration. Use this after configuring a webhook to ensure it works correctly.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"provider": map[string]interface{}{
					"type":        "string",
					"description": "Webhook provider to test: 'discord', 'slack', or 'generic'",
					"enum":        []string{"discord", "slack", "generic"},
				},
			},
			Required: []string{"provider"},
		},
	}, s.handleTestWebhook)

	// Get notification config
	s.mcp.AddTool(mcp.Tool{
		Name:        "get_notification_config",
		Description: "Get current webhook notification configuration. Shows which webhooks are configured and their settings (URLs are partially masked for security).",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleGetNotificationConfig)

	// Manage whitelist
	s.mcp.AddTool(mcp.Tool{
		Name:        "manage_whitelist",
		Description: "Manage the security whitelist for server-specific exceptions. Use this AI-driven tool to add/update whitelist entries when the user confirms certain findings are false positives. The whitelist is saved locally in .chihuaudit-whitelist.yaml (in .gitignore). Supports whitelisting: services on specific ports/binds, wildcard ports (0.0.0.0), and CIS control exceptions.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"action": map[string]interface{}{
					"type":        "string",
					"description": "Action to perform: 'get' (read current), 'add' (add entries), 'save' (persist to disk)",
					"enum":        []string{"get", "add", "save"},
				},
				"service": map[string]interface{}{
					"type":        "object",
					"description": "Service to whitelist (for action=add)",
					"properties": map[string]interface{}{
						"port":    map[string]interface{}{"type": "integer"},
						"bind":    map[string]interface{}{"type": "string"},
						"service": map[string]interface{}{"type": "string"},
						"reason":  map[string]interface{}{"type": "string"},
					},
				},
				"wildcard_port": map[string]interface{}{
					"type":        "integer",
					"description": "Port number to allow on wildcard binding (0.0.0.0/::) - for action=add",
				},
				"cis_exception": map[string]interface{}{
					"type":        "object",
					"description": "CIS control exception (for action=add)",
					"properties": map[string]interface{}{
						"id":     map[string]interface{}{"type": "string"},
						"reason": map[string]interface{}{"type": "string"},
					},
				},
				"server_info": map[string]interface{}{
					"type":        "object",
					"description": "Server metadata (for action=add or save)",
					"properties": map[string]interface{}{
						"role":        map[string]interface{}{"type": "string"},
						"environment": map[string]interface{}{"type": "string"},
						"notes":       map[string]interface{}{"type": "string"},
					},
				},
			},
			Required: []string{"action"},
		},
	}, s.handleManageWhitelist)
}

func (s *Server) getLogDir() string {
	if os.Geteuid() == 0 {
		return "/var/log/chihuaudit"
	}
	return "/tmp/chihuaudit-" + string(rune(os.Getuid()))
}

func (s *Server) handleSecurityAudit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	correlationID := uuid.New().String()
	start := time.Now()

	s.logger.Info("MCP tool call started",
		zap.String("tool", "security_audit"),
		zap.String("correlation_id", correlationID),
	)

	var rawReport map[string]interface{}

	// Check if using pre-loaded data (serve mode)
	if s.preloadedData != nil {
		rawReport = s.preloadedData
		s.logger.Debug("Using preloaded data", zap.String("correlation_id", correlationID))
	} else {
		// Normal mode: run audit (requires sudo)
		maskData := true
		if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
			if v, ok := arguments["mask_data"].(bool); ok {
				maskData = v
			}
		}

		s.logger.Debug("Running audit",
			zap.Bool("mask_data", maskData),
			zap.String("correlation_id", correlationID),
		)

		var err error
		rawReport, err = s.orchestrator.RunAudit(ctx, s.config, maskData)
		if err != nil {
			s.logger.Error("Audit failed",
				zap.Error(err),
				zap.String("correlation_id", correlationID),
				zap.Duration("duration", time.Since(start)),
			)
			return mcp.NewToolResultError(err.Error()), nil
		}
	}

	// Use v1.0 structured format (token-efficient)
	formatter := output.NewStructuredFormatter()
	structuredReport := formatter.FormatReportStructured(rawReport)

	reportJSON, err := structuredReport.ToJSON()
	if err != nil {
		s.logger.Error("Failed to marshal report",
			zap.Error(err),
			zap.String("correlation_id", correlationID),
		)
		return mcp.NewToolResultError(err.Error()), nil
	}

	s.logger.Info("MCP tool call completed",
		zap.String("tool", "security_audit"),
		zap.String("correlation_id", correlationID),
		zap.Duration("duration", time.Since(start)),
		zap.Int("response_size_bytes", len(reportJSON)),
	)

	return mcp.NewToolResultText(reportJSON), nil
}

func (s *Server) handleAnalyzeAnomaly(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	anomalyFile, ok := arguments["anomaly_file"].(string)
	if !ok || anomalyFile == "" {
		return mcp.NewToolResultError("anomaly_file parameter required"), nil
	}

	// Security: Only allow reading from expected log directories
	absPath, err := filepath.Abs(anomalyFile)
	if err != nil {
		return mcp.NewToolResultError("Invalid path: " + err.Error()), nil
	}

	allowedDirs := []string{
		"/var/log/chihuaudit",
		"/tmp/chihuaudit-",
	}

	allowed := false
	for _, dir := range allowedDirs {
		if strings.HasPrefix(absPath, dir) {
			allowed = true
			break
		}
	}

	if !allowed {
		return mcp.NewToolResultError("Access denied: anomaly file must be in /var/log/chihuaudit or /tmp/chihuaudit-*"), nil
	}

	// Check file extension
	if !strings.HasSuffix(absPath, ".json") {
		return mcp.NewToolResultError("Only .json files are allowed"), nil
	}

	// Read file
	data, err := os.ReadFile(absPath)
	if err != nil {
		return mcp.NewToolResultError("Failed to read anomaly file: " + err.Error()), nil
	}

	var anomalyData map[string]interface{}
	if err := json.Unmarshal(data, &anomalyData); err != nil {
		return mcp.NewToolResultError("Failed to parse anomaly file: " + err.Error()), nil
	}

	// Return for AI analysis
	result := map[string]interface{}{
		"message":       "Security anomaly detected - AI analysis recommended",
		"anomaly_count": len(anomalyData["anomalies"].([]interface{})),
		"anomalies":     anomalyData["anomalies"],
		"timestamp":     anomalyData["timestamp"],
		"full_report":   anomalyData["full_report"],
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleMonitoringStatus(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	status := manager.GetStatus()

	statusJSON, err := json.MarshalIndent(status, "", "  ")
	if err != nil {
		return mcp.NewToolResultError("Failed to marshal status: " + err.Error()), nil
	}
	return mcp.NewToolResultText(string(statusJSON)), nil
}

func (s *Server) handleStartMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	interval := 3600
	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["interval_seconds"].(float64); ok {
			interval = int(v)
		}
	}

	// Validate interval
	if interval < 10 {
		return mcp.NewToolResultError("Minimum interval is 10 seconds"), nil
	}
	if interval > 86400 {
		return mcp.NewToolResultError("Maximum interval is 86400 seconds (24 hours)"), nil
	}

	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Start(interval)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleStopMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Stop()

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCleanupOldLogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.CleanupOldLogs(50, 20)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanNetworkSecurity(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	scope := "local"
	deep := false
	attackerView := false
	cloudContext := false

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["scope"].(string); ok {
			scope = v
		}
		if v, ok := arguments["deep"].(bool); ok {
			deep = v
		}
		if v, ok := arguments["attacker_view"].(bool); ok {
			attackerView = v
		}
		if v, ok := arguments["cloud_context"].(bool); ok {
			cloudContext = v
		}
	}

	result := scanners.ScanNetworkSecurity(ctx, scope, deep, attackerView, cloudContext)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleVerifyBackupConfig(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	result := scanners.VerifyBackupConfig(ctx)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanDatabaseSecurity(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	dbType := "auto"

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["db_type"].(string); ok {
			dbType = v
		}
	}

	result := scanners.ScanDatabaseSecurity(ctx, dbType)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCheckVulnerabilityIntel(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	cveIDsRaw, ok := arguments["cve_ids"].([]interface{})
	if !ok {
		return mcp.NewToolResultError("cve_ids parameter required"), nil
	}

	var cveIDs []string
	for _, id := range cveIDsRaw {
		if s, ok := id.(string); ok {
			cveIDs = append(cveIDs, s)
		}
	}

	result := scanners.CheckVulnerabilityIntel(ctx, cveIDs)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanWAFCDN(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	domain, ok := arguments["domain"].(string)
	if !ok || domain == "" {
		return mcp.NewToolResultError("domain parameter required"), nil
	}

	includeHeaders := false
	if v, ok := arguments["include_headers"].(bool); ok {
		includeHeaders = v
	}

	result := scanners.ScanWAFCDN(ctx, domain, includeHeaders)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCISAudit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	level := 1
	includeAllControls := false

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["level"].(float64); ok {
			level = int(v)
		}
		if v, ok := arguments["include_all_controls"].(bool); ok {
			includeAllControls = v
		}
	}

	// Validate level
	if level != 1 && level != 2 {
		level = 1
	}

	// Run CIS audit with compact output by default
	result := cis.RunCISAudit(ctx, level, includeAllControls, s.config.Whitelist)

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return mcp.NewToolResultError("Failed to marshal CIS result: " + err.Error()), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleConfigureWebhook(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	provider, ok := arguments["provider"].(string)
	if !ok || provider == "" {
		return mcp.NewToolResultError("provider parameter required"), nil
	}

	webhookURL, ok := arguments["webhook_url"].(string)
	if !ok || webhookURL == "" {
		return mcp.NewToolResultError("webhook_url parameter required"), nil
	}

	enabled := true
	if v, ok := arguments["enabled"].(bool); ok {
		enabled = v
	}

	onlyOnIssues := true
	if v, ok := arguments["only_on_issues"].(bool); ok {
		onlyOnIssues = v
	}

	minSeverity := "high"
	if v, ok := arguments["min_severity"].(string); ok {
		minSeverity = v
	}

	// Update config
	s.config.Notifications.Enabled = enabled
	s.config.Notifications.OnlyOnIssues = onlyOnIssues
	s.config.Notifications.MinSeverity = minSeverity

	switch provider {
	case "discord":
		s.config.Notifications.Discord.Enabled = enabled
		s.config.Notifications.Discord.WebhookURL = webhookURL
	case "slack":
		s.config.Notifications.Slack.Enabled = enabled
		s.config.Notifications.Slack.WebhookURL = webhookURL
	case "generic":
		s.config.Notifications.GenericWebhook.Enabled = enabled
		s.config.Notifications.GenericWebhook.URL = webhookURL
	default:
		return mcp.NewToolResultError("Invalid provider. Use 'discord', 'slack', or 'generic'"), nil
	}

	// Save config to file
	if err := s.saveNotificationConfig(); err != nil {
		return mcp.NewToolResultError("Failed to save config: " + err.Error()), nil
	}

	result := map[string]interface{}{
		"success":        true,
		"provider":       provider,
		"enabled":        enabled,
		"only_on_issues": onlyOnIssues,
		"min_severity":   minSeverity,
		"message":        "Webhook configured successfully. Use 'test_webhook' to verify.",
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleTestWebhook(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	provider, ok := arguments["provider"].(string)
	if !ok || provider == "" {
		return mcp.NewToolResultError("provider parameter required"), nil
	}

	notifier := notify.NewNotifier(&s.config.Notifications)
	if err := notifier.TestWebhook(ctx, provider); err != nil {
		return mcp.NewToolResultError("Webhook test failed: " + err.Error()), nil
	}

	result := map[string]interface{}{
		"success":  true,
		"provider": provider,
		"message":  "Test notification sent successfully!",
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleGetNotificationConfig(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Mask webhook URLs for security
	maskURL := func(url string) string {
		if url == "" {
			return "(not configured)"
		}
		if len(url) < 20 {
			return "****"
		}
		return url[:15] + "..." + url[len(url)-10:]
	}

	result := map[string]interface{}{
		"enabled":        s.config.Notifications.Enabled,
		"only_on_issues": s.config.Notifications.OnlyOnIssues,
		"min_severity":   s.config.Notifications.MinSeverity,
		"discord": map[string]interface{}{
			"enabled":     s.config.Notifications.Discord.Enabled,
			"webhook_url": maskURL(s.config.Notifications.Discord.WebhookURL),
			"username":    s.config.Notifications.Discord.Username,
		},
		"slack": map[string]interface{}{
			"enabled":     s.config.Notifications.Slack.Enabled,
			"webhook_url": maskURL(s.config.Notifications.Slack.WebhookURL),
			"channel":     s.config.Notifications.Slack.Channel,
			"username":    s.config.Notifications.Slack.Username,
		},
		"generic_webhook": map[string]interface{}{
			"enabled": s.config.Notifications.GenericWebhook.Enabled,
			"url":     maskURL(s.config.Notifications.GenericWebhook.URL),
			"method":  s.config.Notifications.GenericWebhook.Method,
		},
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleManageWhitelist(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	action, ok := arguments["action"].(string)
	if !ok {
		return mcp.NewToolResultError("action parameter required"), nil
	}

	switch action {
	case "get":
		// Return current whitelist
		resultJSON, _ := json.MarshalIndent(s.config.Whitelist, "", "  ")
		return mcp.NewToolResultText(string(resultJSON)), nil

	case "add":
		// Add entries to whitelist
		if svcData, ok := arguments["service"].(map[string]interface{}); ok {
			svc := config.ServiceWhitelist{}
			if port, ok := svcData["port"].(float64); ok {
				svc.Port = int(port)
			}
			if bind, ok := svcData["bind"].(string); ok {
				svc.Bind = bind
			}
			if service, ok := svcData["service"].(string); ok {
				svc.Service = service
			}
			if reason, ok := svcData["reason"].(string); ok {
				svc.Reason = reason
			}
			s.config.Whitelist.Services = append(s.config.Whitelist.Services, svc)
		}

		if port, ok := arguments["wildcard_port"].(float64); ok {
			s.config.Whitelist.Network.AllowedWildcardPorts = append(
				s.config.Whitelist.Network.AllowedWildcardPorts,
				int(port),
			)
		}

		if cisData, ok := arguments["cis_exception"].(map[string]interface{}); ok {
			exc := config.CISException{}
			if id, ok := cisData["id"].(string); ok {
				exc.ID = id
			}
			if reason, ok := cisData["reason"].(string); ok {
				exc.Reason = reason
			}
			s.config.Whitelist.CIS.Exceptions = append(s.config.Whitelist.CIS.Exceptions, exc)
		}

		if serverInfo, ok := arguments["server_info"].(map[string]interface{}); ok {
			if role, ok := serverInfo["role"].(string); ok {
				s.config.Whitelist.Server.Role = role
			}
			if env, ok := serverInfo["environment"].(string); ok {
				s.config.Whitelist.Server.Environment = env
			}
			if notes, ok := serverInfo["notes"].(string); ok {
				s.config.Whitelist.Server.Notes = notes
			}
		}

		return mcp.NewToolResultText("Entry added to whitelist (in memory). Use action='save' to persist."), nil

	case "save":
		// Save whitelist to disk
		if err := config.SaveWhitelist(s.config.Whitelist, ".chihuaudit-whitelist.yaml"); err != nil {
			return mcp.NewToolResultError("Failed to save whitelist: " + err.Error()), nil
		}
		return mcp.NewToolResultText("Whitelist saved to .chihuaudit-whitelist.yaml"), nil

	default:
		return mcp.NewToolResultError("Invalid action. Use 'get', 'add', or 'save'"), nil
	}
}

func (s *Server) saveNotificationConfig() error {
	// Find or create config file
	home, _ := os.UserHomeDir()
	configPath := filepath.Join(home, ".chihuaudit.yaml")

	// Read existing config if any
	existingData, _ := os.ReadFile(configPath)

	// Simple YAML append/update for notifications section
	notifyConfig := `
notifications:
  enabled: ` + boolToYAML(s.config.Notifications.Enabled) + `
  onlyOnIssues: ` + boolToYAML(s.config.Notifications.OnlyOnIssues) + `
  minSeverity: "` + s.config.Notifications.MinSeverity + `"
  discord:
    enabled: ` + boolToYAML(s.config.Notifications.Discord.Enabled) + `
    webhookUrl: "` + s.config.Notifications.Discord.WebhookURL + `"
    username: "` + s.config.Notifications.Discord.Username + `"
  slack:
    enabled: ` + boolToYAML(s.config.Notifications.Slack.Enabled) + `
    webhookUrl: "` + s.config.Notifications.Slack.WebhookURL + `"
    channel: "` + s.config.Notifications.Slack.Channel + `"
    username: "` + s.config.Notifications.Slack.Username + `"
  webhook:
    enabled: ` + boolToYAML(s.config.Notifications.GenericWebhook.Enabled) + `
    url: "` + s.config.Notifications.GenericWebhook.URL + `"
    method: "` + s.config.Notifications.GenericWebhook.Method + `"
`

	// If file exists and has notifications section, we need to be smarter
	// For now, simple append if not exists or write new
	content := string(existingData)
	if strings.Contains(content, "notifications:") {
		// Replace existing notifications section (simple approach)
		// In production, use proper YAML merge
		return os.WriteFile(configPath, []byte(notifyConfig), 0600)
	}

	// Append to existing
	newContent := content + notifyConfig
	return os.WriteFile(configPath, []byte(newContent), 0600)
}

func boolToYAML(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// Serve starts the MCP server
func (s *Server) Serve() error {
	return server.ServeStdio(s.mcp)
}
