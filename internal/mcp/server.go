package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/girste/chihuaudit/internal/audit"
	"github.com/girste/chihuaudit/internal/config"
	"github.com/girste/chihuaudit/internal/monitoring"
	"github.com/girste/chihuaudit/internal/notify"
	"github.com/girste/chihuaudit/internal/output"
	"github.com/girste/chihuaudit/internal/util"
	"github.com/google/uuid"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"go.uber.org/zap"
)

// Server wraps the MCP server
type Server struct {
	mcp           *server.MCPServer
	orchestrator  *audit.Orchestrator
	config        *config.Config
	preloadedData map[string]interface{} // For serve mode (no sudo)
	logger        *zap.Logger
}

// NewServer creates a new MCP server
func NewServer() (*Server, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}

	logger := util.GetLogger()

	mcpServer := server.NewMCPServer(
		"chihuaudit",
		"1.0.0",
		server.WithLogging(),
	)

	s := &Server{
		mcp:          mcpServer,
		orchestrator: audit.NewOrchestrator(),
		config:       cfg,
		logger:       logger,
	}

	s.registerTools()

	logger.Info("MCP server initialized", zap.String("version", "1.0.0"))

	return s, nil
}

// NewServerWithData creates MCP server with pre-loaded audit data (no sudo mode)
func NewServerWithData(auditData map[string]interface{}) (*Server, error) {
	cfg, err := config.Load()
	if err != nil {
		// Non-critical in serve mode
		cfg = &config.Config{}
	}

	logger := util.GetLogger()

	mcpServer := server.NewMCPServer(
		"chihuaudit",
		"1.0.0",
		server.WithLogging(),
	)

	s := &Server{
		mcp:           mcpServer,
		config:        cfg,
		preloadedData: auditData,
		logger:        logger,
		// orchestrator intentionally nil (serve mode doesn't audit)
	}

	s.registerTools()

	logger.Info("MCP server initialized in serve mode", zap.Bool("preloaded", auditData != nil))

	return s, nil
}

func (s *Server) registerTools() {
	// Security audit tool
	s.mcp.AddTool(mcp.Tool{
		Name:        "security_audit",
		Description: "Run comprehensive cybersecurity audit of the Linux server. Analyzes: firewall (ufw/iptables/firewalld), SSH configuration, threat patterns, fail2ban, network services/open ports, Docker security, security updates, MAC (AppArmor/SELinux), and kernel hardening. Returns detailed JSON report with security score and actionable recommendations.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"mask_data": map[string]interface{}{
					"type":        "boolean",
					"description": "Mask sensitive data like IPs and hostname (default: true)",
					"default":     true,
				},
			},
		},
	}, s.handleSecurityAudit)

	// Analyze anomaly
	s.mcp.AddTool(mcp.Tool{
		Name:        "analyze_anomaly",
		Description: "Analyze security anomaly with AI-powered insights. Use this when the monitoring system detects anomalies (firewall changes, new open ports, SSH config changes, attack spikes, etc.). Provides deep analysis of what changed, why it's concerning, and recommended actions. This tool should ONLY be called when anomalies are detected - don't waste tokens on normal state.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"anomaly_file": map[string]interface{}{
					"type":        "string",
					"description": "Path to anomaly report JSON file (generated by monitor)",
				},
			},
			Required: []string{"anomaly_file"},
		},
	}, s.handleAnalyzeAnomaly)

	// Monitoring status
	s.mcp.AddTool(mcp.Tool{
		Name:        "monitoring_status",
		Description: "Get current status of security monitoring daemon. Shows if monitoring is running, how many logs collected, disk usage, etc. Use this to check monitoring state before starting/stopping it.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleMonitoringStatus)

	// Start monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "start_monitoring",
		Description: "Start continuous security monitoring in background. The daemon will check security state periodically and alert on anomalies. IMPORTANT: Ask user for confirmation before starting! This runs a background process.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"interval_seconds": map[string]interface{}{
					"type":        "number",
					"description": "Check interval in seconds (default: 3600 = 1 hour, configurable via scoring.minInterval/maxInterval)",
					"default":     3600,
				},
			},
		},
	}, s.handleStartMonitoring)

	// Stop monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "stop_monitoring",
		Description: "Stop security monitoring daemon. IMPORTANT: Ask user for confirmation before stopping!",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleStopMonitoring)

	// Cleanup old logs
	s.mcp.AddTool(mcp.Tool{
		Name:        "cleanup_old_logs",
		Description: "Remove old monitoring logs to free disk space. Keeps most recent 50 bulletins and 20 anomaly reports, deletes older ones. Safe to run periodically to prevent disk fill.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleCleanupOldLogs)

	// Configure webhook notifications
	s.mcp.AddTool(mcp.Tool{
		Name:        "configure_webhook",
		Description: "Configure webhook notifications for security alerts. Supports Discord, Slack, and generic webhooks. The webhook URL will be saved to the config file. Use this to set up real-time alerts when security issues are detected. IMPORTANT: Ask the user for their webhook URL before calling this tool.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"provider": map[string]interface{}{
					"type":        "string",
					"description": "Webhook provider: 'discord', 'slack', or 'generic'",
					"enum":        []string{"discord", "slack", "generic"},
				},
				"webhook_url": map[string]interface{}{
					"type":        "string",
					"description": "The webhook URL to send notifications to",
				},
				"enabled": map[string]interface{}{
					"type":        "boolean",
					"description": "Enable or disable notifications (default: true)",
					"default":     true,
				},
				"only_on_issues": map[string]interface{}{
					"type":        "boolean",
					"description": "Only send notifications when issues are found (default: true)",
					"default":     true,
				},
				"min_severity": map[string]interface{}{
					"type":        "string",
					"description": "Minimum severity to trigger notifications: 'critical', 'high', 'medium', 'low' (default: 'high')",
					"enum":        []string{"critical", "high", "medium", "low"},
					"default":     "high",
				},
			},
			Required: []string{"provider", "webhook_url"},
		},
	}, s.handleConfigureWebhook)

	// Test webhook
	s.mcp.AddTool(mcp.Tool{
		Name:        "test_webhook",
		Description: "Send a test notification to verify webhook configuration. Use this after configuring a webhook to ensure it works correctly.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"provider": map[string]interface{}{
					"type":        "string",
					"description": "Webhook provider to test: 'discord', 'slack', or 'generic'",
					"enum":        []string{"discord", "slack", "generic"},
				},
			},
			Required: []string{"provider"},
		},
	}, s.handleTestWebhook)

	// Get notification config
	s.mcp.AddTool(mcp.Tool{
		Name:        "get_notification_config",
		Description: "Get current webhook notification configuration. Shows which webhooks are configured and their settings (URLs are partially masked for security).",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleGetNotificationConfig)

	// Manage whitelist
	s.mcp.AddTool(mcp.Tool{
		Name:        "manage_whitelist",
		Description: "Manage the security whitelist for server-specific exceptions. Use this AI-driven tool to add/update whitelist entries when the user confirms certain findings are false positives. The whitelist is saved locally in .chihuaudit-whitelist.yaml (in .gitignore). Supports whitelisting: services on specific ports/binds, wildcard ports (0.0.0.0), and CIS control exceptions.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"action": map[string]interface{}{
					"type":        "string",
					"description": "Action to perform: 'get' (read current), 'add' (add entries), 'save' (persist to disk)",
					"enum":        []string{"get", "add", "save"},
				},
				"service": map[string]interface{}{
					"type":        "object",
					"description": "Service to whitelist (for action=add)",
					"properties": map[string]interface{}{
						"port":    map[string]interface{}{"type": "integer"},
						"bind":    map[string]interface{}{"type": "string"},
						"service": map[string]interface{}{"type": "string"},
						"reason":  map[string]interface{}{"type": "string"},
					},
				},
				"wildcard_port": map[string]interface{}{
					"type":        "integer",
					"description": "Port number to allow on wildcard binding (0.0.0.0/::) - for action=add",
				},
				"cis_exception": map[string]interface{}{
					"type":        "object",
					"description": "CIS control exception (for action=add)",
					"properties": map[string]interface{}{
						"id":     map[string]interface{}{"type": "string"},
						"reason": map[string]interface{}{"type": "string"},
					},
				},
				"server_info": map[string]interface{}{
					"type":        "object",
					"description": "Server metadata (for action=add or save)",
					"properties": map[string]interface{}{
						"role":        map[string]interface{}{"type": "string"},
						"environment": map[string]interface{}{"type": "string"},
						"notes":       map[string]interface{}{"type": "string"},
					},
				},
			},
			Required: []string{"action"},
		},
	}, s.handleManageWhitelist)
}

func (s *Server) getLogDir() string {
	if os.Geteuid() == 0 {
		return "/var/log/chihuaudit"
	}
	return fmt.Sprintf("/tmp/chihuaudit-%d", os.Getuid())
}

func (s *Server) handleSecurityAudit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	correlationID := uuid.New().String()
	start := time.Now()

	s.logger.Info("MCP tool call started",
		zap.String("tool", "security_audit"),
		zap.String("correlation_id", correlationID),
	)

	var rawReport map[string]interface{}

	// Check if using pre-loaded data (serve mode)
	if s.preloadedData != nil {
		rawReport = s.preloadedData
		s.logger.Debug("Using preloaded data", zap.String("correlation_id", correlationID))
	} else {
		// Normal mode: run audit (requires sudo)
		maskData := true
		if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
			if v, ok := arguments["mask_data"].(bool); ok {
				maskData = v
			}
		}

		s.logger.Debug("Running audit",
			zap.Bool("mask_data", maskData),
			zap.String("correlation_id", correlationID),
		)

		var err error
		rawReport, err = s.orchestrator.RunAudit(ctx, s.config, maskData)
		if err != nil {
			s.logger.Error("Audit failed",
				zap.Error(err),
				zap.String("correlation_id", correlationID),
				zap.Duration("duration", time.Since(start)),
			)
			return mcp.NewToolResultError(err.Error()), nil
		}
	}

	// Use v1.0 structured format (token-efficient)
	formatter := output.NewStructuredFormatter()
	structuredReport := formatter.FormatReportStructured(rawReport)

	reportJSON, err := structuredReport.ToJSON()
	if err != nil {
		s.logger.Error("Failed to marshal report",
			zap.Error(err),
			zap.String("correlation_id", correlationID),
		)
		return mcp.NewToolResultError(err.Error()), nil
	}

	s.logger.Info("MCP tool call completed",
		zap.String("tool", "security_audit"),
		zap.String("correlation_id", correlationID),
		zap.Duration("duration", time.Since(start)),
		zap.Int("response_size_bytes", len(reportJSON)),
	)

	return mcp.NewToolResultText(reportJSON), nil
}

func (s *Server) handleAnalyzeAnomaly(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	anomalyFile, ok := arguments["anomaly_file"].(string)
	if !ok || anomalyFile == "" {
		return mcp.NewToolResultError("anomaly_file parameter required"), nil
	}

	// Security: Only allow reading from expected log directories
	absPath, err := filepath.Abs(anomalyFile)
	if err != nil {
		return mcp.NewToolResultError("Invalid path: " + err.Error()), nil
	}

	allowedDirs := []string{
		"/var/log/chihuaudit",
		"/tmp/chihuaudit-",
	}

	allowed := false
	for _, dir := range allowedDirs {
		if strings.HasPrefix(absPath, dir) {
			allowed = true
			break
		}
	}

	if !allowed {
		return mcp.NewToolResultError("Access denied: anomaly file must be in /var/log/chihuaudit or /tmp/chihuaudit-*"), nil
	}

	// Check file extension
	if !strings.HasSuffix(absPath, ".json") {
		return mcp.NewToolResultError("Only .json files are allowed"), nil
	}

	// Read file
	data, err := os.ReadFile(absPath)
	if err != nil {
		return mcp.NewToolResultError("Failed to read anomaly file: " + err.Error()), nil
	}

	var anomalyData map[string]interface{}
	if err := json.Unmarshal(data, &anomalyData); err != nil {
		return mcp.NewToolResultError("Failed to parse anomaly file: " + err.Error()), nil
	}

	// Return for AI analysis
	anomalies, _ := anomalyData["anomalies"].([]interface{})
	result := map[string]interface{}{
		"message":       "Security anomaly detected - AI analysis recommended",
		"anomaly_count": len(anomalies),
		"anomalies":     anomalies,
		"timestamp":     anomalyData["timestamp"],
		"full_report":   anomalyData["full_report"],
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleMonitoringStatus(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	status := manager.GetStatus()

	statusJSON, err := json.MarshalIndent(status, "", "  ")
	if err != nil {
		return mcp.NewToolResultError("Failed to marshal status: " + err.Error()), nil
	}
	return mcp.NewToolResultText(string(statusJSON)), nil
}

func (s *Server) handleStartMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	interval := 3600
	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["interval_seconds"].(float64); ok {
			interval = int(v)
		}
	}

	// Validate interval
	cfg, _ := config.Load()
	if cfg == nil {
		cfg = config.Default()
	}
	
	if interval < cfg.Scoring.MinInterval {
		return mcp.NewToolResultError(fmt.Sprintf("Minimum interval is %d seconds", cfg.Scoring.MinInterval)), nil
	}
	if interval > cfg.Scoring.MaxInterval {
		return mcp.NewToolResultError(fmt.Sprintf("Maximum interval is %d seconds", cfg.Scoring.MaxInterval)), nil
	}

	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Start(interval)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleStopMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Stop()

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCleanupOldLogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.CleanupOldLogs(50, 20)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleConfigureWebhook(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	provider, ok := arguments["provider"].(string)
	if !ok || provider == "" {
		return mcp.NewToolResultError("provider parameter required"), nil
	}

	webhookURL, ok := arguments["webhook_url"].(string)
	if !ok || webhookURL == "" {
		return mcp.NewToolResultError("webhook_url parameter required"), nil
	}

	enabled := true
	if v, ok := arguments["enabled"].(bool); ok {
		enabled = v
	}

	onlyOnIssues := true
	if v, ok := arguments["only_on_issues"].(bool); ok {
		onlyOnIssues = v
	}

	minSeverity := "high"
	if v, ok := arguments["min_severity"].(string); ok {
		minSeverity = v
	}

	// Update config
	s.config.Notifications.Enabled = enabled
	s.config.Notifications.OnlyOnIssues = onlyOnIssues
	s.config.Notifications.MinSeverity = minSeverity

	switch provider {
	case "discord":
		s.config.Notifications.Discord.Enabled = enabled
		s.config.Notifications.Discord.WebhookURL = webhookURL
	case "slack":
		s.config.Notifications.Slack.Enabled = enabled
		s.config.Notifications.Slack.WebhookURL = webhookURL
	case "generic":
		s.config.Notifications.GenericWebhook.Enabled = enabled
		s.config.Notifications.GenericWebhook.URL = webhookURL
	default:
		return mcp.NewToolResultError("Invalid provider. Use 'discord', 'slack', or 'generic'"), nil
	}

	// Save config to file
	if err := s.saveNotificationConfig(); err != nil {
		return mcp.NewToolResultError("Failed to save config: " + err.Error()), nil
	}

	result := map[string]interface{}{
		"success":        true,
		"provider":       provider,
		"enabled":        enabled,
		"only_on_issues": onlyOnIssues,
		"min_severity":   minSeverity,
		"message":        "Webhook configured successfully. Use 'test_webhook' to verify.",
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleTestWebhook(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	provider, ok := arguments["provider"].(string)
	if !ok || provider == "" {
		return mcp.NewToolResultError("provider parameter required"), nil
	}

	notifier := notify.NewNotifier(&s.config.Notifications)
	if err := notifier.TestWebhook(ctx, provider); err != nil {
		return mcp.NewToolResultError("Webhook test failed: " + err.Error()), nil
	}

	result := map[string]interface{}{
		"success":  true,
		"provider": provider,
		"message":  "Test notification sent successfully!",
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleGetNotificationConfig(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Mask webhook URLs for security
	maskURL := func(url string) string {
		if url == "" {
			return "(not configured)"
		}
		if len(url) < 20 {
			return "****"
		}
		return url[:15] + "..." + url[len(url)-10:]
	}

	result := map[string]interface{}{
		"enabled":        s.config.Notifications.Enabled,
		"only_on_issues": s.config.Notifications.OnlyOnIssues,
		"min_severity":   s.config.Notifications.MinSeverity,
		"discord": map[string]interface{}{
			"enabled":     s.config.Notifications.Discord.Enabled,
			"webhook_url": maskURL(s.config.Notifications.Discord.WebhookURL),
			"username":    s.config.Notifications.Discord.Username,
		},
		"slack": map[string]interface{}{
			"enabled":     s.config.Notifications.Slack.Enabled,
			"webhook_url": maskURL(s.config.Notifications.Slack.WebhookURL),
			"channel":     s.config.Notifications.Slack.Channel,
			"username":    s.config.Notifications.Slack.Username,
		},
		"generic_webhook": map[string]interface{}{
			"enabled": s.config.Notifications.GenericWebhook.Enabled,
			"url":     maskURL(s.config.Notifications.GenericWebhook.URL),
			"method":  s.config.Notifications.GenericWebhook.Method,
		},
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleManageWhitelist(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	action, ok := arguments["action"].(string)
	if !ok {
		return mcp.NewToolResultError("action parameter required"), nil
	}

	switch action {
	case "get":
		// Return current whitelist
		resultJSON, _ := json.MarshalIndent(s.config.Whitelist, "", "  ")
		return mcp.NewToolResultText(string(resultJSON)), nil

	case "add":
		// Add entries to whitelist
		if svcData, ok := arguments["service"].(map[string]interface{}); ok {
			svc := config.ServiceWhitelist{}
			if port, ok := svcData["port"].(float64); ok {
				svc.Port = int(port)
			}
			if bind, ok := svcData["bind"].(string); ok {
				svc.Bind = bind
			}
			if service, ok := svcData["service"].(string); ok {
				svc.Service = service
			}
			if reason, ok := svcData["reason"].(string); ok {
				svc.Reason = reason
			}
			s.config.Whitelist.Services = append(s.config.Whitelist.Services, svc)
		}

		if port, ok := arguments["wildcard_port"].(float64); ok {
			s.config.Whitelist.Network.AllowedWildcardPorts = append(
				s.config.Whitelist.Network.AllowedWildcardPorts,
				int(port),
			)
		}

		if cisData, ok := arguments["cis_exception"].(map[string]interface{}); ok {
			exc := config.CISException{}
			if id, ok := cisData["id"].(string); ok {
				exc.ID = id
			}
			if reason, ok := cisData["reason"].(string); ok {
				exc.Reason = reason
			}
			s.config.Whitelist.CIS.Exceptions = append(s.config.Whitelist.CIS.Exceptions, exc)
		}

		if serverInfo, ok := arguments["server_info"].(map[string]interface{}); ok {
			if role, ok := serverInfo["role"].(string); ok {
				s.config.Whitelist.Server.Role = role
			}
			if env, ok := serverInfo["environment"].(string); ok {
				s.config.Whitelist.Server.Environment = env
			}
			if notes, ok := serverInfo["notes"].(string); ok {
				s.config.Whitelist.Server.Notes = notes
			}
		}

		return mcp.NewToolResultText("Entry added to whitelist (in memory). Use action='save' to persist."), nil

	case "save":
		// Save whitelist to disk
		if err := config.SaveWhitelist(s.config.Whitelist, ".chihuaudit-whitelist.yaml"); err != nil {
			return mcp.NewToolResultError("Failed to save whitelist: " + err.Error()), nil
		}
		return mcp.NewToolResultText("Whitelist saved to .chihuaudit-whitelist.yaml"), nil

	default:
		return mcp.NewToolResultError("Invalid action. Use 'get', 'add', or 'save'"), nil
	}
}

func (s *Server) saveNotificationConfig() error {
	// Find or create config file
	home, _ := os.UserHomeDir()
	configPath := filepath.Join(home, ".chihuaudit.yaml")

	// Read existing config if any
	existingData, _ := os.ReadFile(configPath)

	// Simple YAML append/update for notifications section
	notifyConfig := `
notifications:
  enabled: ` + boolToYAML(s.config.Notifications.Enabled) + `
  onlyOnIssues: ` + boolToYAML(s.config.Notifications.OnlyOnIssues) + `
  minSeverity: "` + s.config.Notifications.MinSeverity + `"
  discord:
    enabled: ` + boolToYAML(s.config.Notifications.Discord.Enabled) + `
    webhookUrl: "` + s.config.Notifications.Discord.WebhookURL + `"
    username: "` + s.config.Notifications.Discord.Username + `"
  slack:
    enabled: ` + boolToYAML(s.config.Notifications.Slack.Enabled) + `
    webhookUrl: "` + s.config.Notifications.Slack.WebhookURL + `"
    channel: "` + s.config.Notifications.Slack.Channel + `"
    username: "` + s.config.Notifications.Slack.Username + `"
  webhook:
    enabled: ` + boolToYAML(s.config.Notifications.GenericWebhook.Enabled) + `
    url: "` + s.config.Notifications.GenericWebhook.URL + `"
    method: "` + s.config.Notifications.GenericWebhook.Method + `"
`

	content := string(existingData)
	if strings.Contains(content, "notifications:") {
		// Preserve everything before the notifications: section
		if strings.HasPrefix(content, "notifications:") {
			// notifications is at the very start â€” replace entirely
			return os.WriteFile(configPath, []byte(notifyConfig), 0600)
		}
		if idx := strings.Index(content, "\nnotifications:"); idx >= 0 {
			// Keep everything up to (not including) the notifications line
			content = content[:idx]
		}
	}

	newContent := content + notifyConfig
	return os.WriteFile(configPath, []byte(newContent), 0600)
}

func boolToYAML(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// Serve starts the MCP server
func (s *Server) Serve() error {
	return server.ServeStdio(s.mcp)
}
