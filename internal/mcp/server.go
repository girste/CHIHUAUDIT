package mcp

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"

	"github.com/girste/mcp-cybersec-watchdog/internal/audit"
	"github.com/girste/mcp-cybersec-watchdog/internal/config"
	"github.com/girste/mcp-cybersec-watchdog/internal/monitoring"
	"github.com/girste/mcp-cybersec-watchdog/internal/scanners"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// Server wraps the MCP server
type Server struct {
	mcp          *server.MCPServer
	orchestrator *audit.Orchestrator
	config       *config.Config
}

// NewServer creates a new MCP server
func NewServer() (*Server, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}

	mcpServer := server.NewMCPServer(
		"mcp-cybersec-watchdog",
		"1.0.0",
		server.WithLogging(),
	)

	s := &Server{
		mcp:          mcpServer,
		orchestrator: audit.NewOrchestrator(),
		config:       cfg,
	}

	s.registerTools()

	return s, nil
}

func (s *Server) registerTools() {
	// Security audit tool
	s.mcp.AddTool(mcp.Tool{
		Name:        "security_audit",
		Description: "Run comprehensive cybersecurity audit of the Linux server. Analyzes: firewall (ufw/iptables/firewalld), SSH configuration, threat patterns, fail2ban, network services/open ports, Docker security, security updates, MAC (AppArmor/SELinux), and kernel hardening. Returns detailed JSON report with security score and actionable recommendations.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"mask_data": map[string]interface{}{
					"type":        "boolean",
					"description": "Mask sensitive data like IPs and hostname (default: true)",
					"default":     true,
				},
			},
		},
	}, s.handleSecurityAudit)

	// Analyze anomaly
	s.mcp.AddTool(mcp.Tool{
		Name:        "analyze_anomaly",
		Description: "Analyze security anomaly with AI-powered insights. Use this when the monitoring system detects anomalies (firewall changes, new open ports, SSH config changes, attack spikes, etc.). Provides deep analysis of what changed, why it's concerning, and recommended actions. This tool should ONLY be called when anomalies are detected - don't waste tokens on normal state.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"anomaly_file": map[string]interface{}{
					"type":        "string",
					"description": "Path to anomaly report JSON file (generated by monitor)",
				},
			},
			Required: []string{"anomaly_file"},
		},
	}, s.handleAnalyzeAnomaly)

	// Monitoring status
	s.mcp.AddTool(mcp.Tool{
		Name:        "monitoring_status",
		Description: "Get current status of security monitoring daemon. Shows if monitoring is running, how many logs collected, disk usage, etc. Use this to check monitoring state before starting/stopping it.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleMonitoringStatus)

	// Start monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "start_monitoring",
		Description: "Start continuous security monitoring in background. The daemon will check security state periodically and alert on anomalies. IMPORTANT: Ask user for confirmation before starting! This runs a background process.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"interval_seconds": map[string]interface{}{
					"type":        "number",
					"description": "Check interval in seconds (default: 3600 = 1 hour, min: 300 = 5 min)",
					"default":     3600,
				},
			},
		},
	}, s.handleStartMonitoring)

	// Stop monitoring
	s.mcp.AddTool(mcp.Tool{
		Name:        "stop_monitoring",
		Description: "Stop security monitoring daemon. IMPORTANT: Ask user for confirmation before stopping!",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleStopMonitoring)

	// Cleanup old logs
	s.mcp.AddTool(mcp.Tool{
		Name:        "cleanup_old_logs",
		Description: "Remove old monitoring logs to free disk space. Keeps most recent 50 bulletins and 20 anomaly reports, deletes older ones. Safe to run periodically to prevent disk fill.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleCleanupOldLogs)

	// Scan app security
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_app_security",
		Description: "Scan applications for security vulnerabilities in dependencies and code. Auto-detects tech stacks (Node.js, Python, Rust, Go, PHP, Java, Ruby, .NET). Checks: dependency CVEs, hardcoded secrets, insecure configurations. Use depth='quick' for fast dependency-only scan, 'standard' for deps+secrets+config, 'deep' for full analysis with detailed secret locations.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"path": map[string]interface{}{
					"type":        "string",
					"description": "Path to application directory (auto-detect all apps if omitted)",
				},
				"depth": map[string]interface{}{
					"type":        "string",
					"description": "Scan depth: 'quick' (deps only), 'standard' (deps+secrets+config), 'deep' (full SAST)",
					"enum":        []string{"quick", "standard", "deep"},
					"default":     "standard",
				},
			},
		},
	}, s.handleScanAppSecurity)

	// Scan network security
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_network_security",
		Description: "Analyze network security posture and attack surface. LOCAL scope: port bindings, wildcard listeners (0.0.0.0), risky exposed services, IPv6. EXTERNAL scope: public IP detection, open port scan, SSL/TLS analysis, DNS security (SPF/DMARC/CAA). Use scope='local' for safe internal checks, 'external' for internet-facing analysis, 'both' for complete audit.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"scope": map[string]interface{}{
					"type":        "string",
					"description": "Scan scope: 'local' (safe), 'external' (requires public access), 'both' (complete)",
					"enum":        []string{"local", "external", "both"},
					"default":     "local",
				},
				"deep": map[string]interface{}{
					"type":        "boolean",
					"description": "Enable deep analysis (SSL/TLS ciphers, DNS records) - only for external scope",
					"default":     false,
				},
			},
		},
	}, s.handleScanNetworkSecurity)

	// Verify backup config
	s.mcp.AddTool(mcp.Tool{
		Name:        "verify_backup_config",
		Description: "Audit backup and disaster recovery configuration. Checks: installed backup tools (restic/borg/duplicity), scheduled backups (cron/systemd), backup destinations (local/remote), encryption status, last backup run. DOES NOT perform backups, only verifies configuration for disaster recovery readiness.",
		InputSchema: mcp.ToolInputSchema{
			Type:       "object",
			Properties: map[string]interface{}{},
		},
	}, s.handleVerifyBackupConfig)

	// Scan database security
	s.mcp.AddTool(mcp.Tool{
		Name:        "scan_database_security",
		Description: "Audit database security configuration for running databases. Auto-detects MySQL/MariaDB, PostgreSQL, MongoDB, Redis. Checks: default credentials, weak passwords, remote access (0.0.0.0), authentication disabled, dangerous commands enabled, user privileges. Use db_type='auto' for auto-detection or specify 'mysql', 'postgresql', 'mongodb', 'redis'.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"db_type": map[string]interface{}{
					"type":        "string",
					"description": "Database type: 'auto' (detect all), 'mysql', 'postgresql', 'mongodb', 'redis'",
					"enum":        []string{"auto", "mysql", "postgresql", "mongodb", "redis"},
					"default":     "auto",
				},
			},
		},
	}, s.handleScanDatabaseSecurity)

	// Check vulnerability intel
	s.mcp.AddTool(mcp.Tool{
		Name:        "check_vulnerability_intel",
		Description: "Check if CVEs have known exploits or are actively exploited in the wild. Uses free public APIs: CISA KEV (Known Exploited Vulnerabilities), NVD (National Vulnerability Database). NO registration or API keys required. Identifies critical-risk CVEs that are being actively exploited and require immediate patching.",
		InputSchema: mcp.ToolInputSchema{
			Type: "object",
			Properties: map[string]interface{}{
				"cve_ids": map[string]interface{}{
					"type":        "array",
					"items":       map[string]interface{}{"type": "string"},
					"description": "List of CVE IDs to check (e.g., ['CVE-2024-1234', 'CVE-2023-5678'])",
				},
			},
			Required: []string{"cve_ids"},
		},
	}, s.handleCheckVulnerabilityIntel)
}

func (s *Server) getLogDir() string {
	if os.Geteuid() == 0 {
		return "/var/log/mcp-watchdog"
	}
	return "/tmp/mcp-watchdog-" + string(rune(os.Getuid()))
}

func (s *Server) handleSecurityAudit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	maskData := true
	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["mask_data"].(bool); ok {
			maskData = v
		}
	}

	report, err := s.orchestrator.RunAudit(ctx, s.config, maskData)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	reportJSON, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	return mcp.NewToolResultText(string(reportJSON)), nil
}

func (s *Server) handleAnalyzeAnomaly(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	anomalyFile, ok := arguments["anomaly_file"].(string)
	if !ok || anomalyFile == "" {
		return mcp.NewToolResultError("anomaly_file parameter required"), nil
	}

	// Security: Only allow reading from expected log directories
	absPath, err := filepath.Abs(anomalyFile)
	if err != nil {
		return mcp.NewToolResultError("Invalid path: " + err.Error()), nil
	}

	allowedDirs := []string{
		"/var/log/mcp-watchdog",
		"/tmp/mcp-watchdog-",
	}

	allowed := false
	for _, dir := range allowedDirs {
		if strings.HasPrefix(absPath, dir) {
			allowed = true
			break
		}
	}

	if !allowed {
		return mcp.NewToolResultError("Access denied: anomaly file must be in /var/log/mcp-watchdog or /tmp/mcp-watchdog-*"), nil
	}

	// Check file extension
	if !strings.HasSuffix(absPath, ".json") {
		return mcp.NewToolResultError("Only .json files are allowed"), nil
	}

	// Read file
	data, err := os.ReadFile(absPath)
	if err != nil {
		return mcp.NewToolResultError("Failed to read anomaly file: " + err.Error()), nil
	}

	var anomalyData map[string]interface{}
	if err := json.Unmarshal(data, &anomalyData); err != nil {
		return mcp.NewToolResultError("Failed to parse anomaly file: " + err.Error()), nil
	}

	// Return for AI analysis
	result := map[string]interface{}{
		"message":       "Security anomaly detected - AI analysis recommended",
		"anomaly_count": len(anomalyData["anomalies"].([]interface{})),
		"anomalies":     anomalyData["anomalies"],
		"timestamp":     anomalyData["timestamp"],
		"full_report":   anomalyData["full_report"],
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleMonitoringStatus(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	status := manager.GetStatus()

	statusJSON, err := json.MarshalIndent(status, "", "  ")
	if err != nil {
		return mcp.NewToolResultError("Failed to marshal status: " + err.Error()), nil
	}
	return mcp.NewToolResultText(string(statusJSON)), nil
}

func (s *Server) handleStartMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	interval := 3600
	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["interval_seconds"].(float64); ok {
			interval = int(v)
		}
	}

	// Validate interval
	if interval < 300 {
		return mcp.NewToolResultError("Minimum interval is 300 seconds (5 minutes)"), nil
	}
	if interval > 86400 {
		return mcp.NewToolResultError("Maximum interval is 86400 seconds (24 hours)"), nil
	}

	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Start(interval)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleStopMonitoring(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.Stop()

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCleanupOldLogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	manager := monitoring.NewMonitoringManager(s.getLogDir())
	result := manager.CleanupOldLogs(50, 20)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanAppSecurity(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	path := ""
	depth := "standard"

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["path"].(string); ok {
			path = v
		}
		if v, ok := arguments["depth"].(string); ok {
			depth = v
		}
	}

	result := scanners.ScanAppSecurity(ctx, path, depth)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanNetworkSecurity(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	scope := "local"
	deep := false

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["scope"].(string); ok {
			scope = v
		}
		if v, ok := arguments["deep"].(bool); ok {
			deep = v
		}
	}

	result := scanners.ScanNetworkSecurity(ctx, scope, deep)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleVerifyBackupConfig(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	result := scanners.VerifyBackupConfig(ctx)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleScanDatabaseSecurity(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	dbType := "auto"

	if arguments, ok := request.Params.Arguments.(map[string]interface{}); ok {
		if v, ok := arguments["db_type"].(string); ok {
			dbType = v
		}
	}

	result := scanners.ScanDatabaseSecurity(ctx, dbType)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCheckVulnerabilityIntel(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments, ok := request.Params.Arguments.(map[string]interface{})
	if !ok {
		return mcp.NewToolResultError("Invalid arguments"), nil
	}

	cveIDsRaw, ok := arguments["cve_ids"].([]interface{})
	if !ok {
		return mcp.NewToolResultError("cve_ids parameter required"), nil
	}

	var cveIDs []string
	for _, id := range cveIDsRaw {
		if s, ok := id.(string); ok {
			cveIDs = append(cveIDs, s)
		}
	}

	result := scanners.CheckVulnerabilityIntel(ctx, cveIDs)

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

// Serve starts the MCP server
func (s *Server) Serve() error {
	return server.ServeStdio(s.mcp)
}
